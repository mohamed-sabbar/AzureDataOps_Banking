trigger:
  branches:
    include:
      - main
  paths:
    include:
      - notebooks/**

pool:
  vmImage: 'ubuntu-latest'

variables:
  - group: variable group
  - name: DATABRICKS_HOST
    value: 'https://adb-1119135389290183.3.azuredatabricks.net'
  - name: DATABRICKS_WORKSPACE_PATH
    value: '/Workspace/Users/mohamedazrou2003@gmail.com'

steps:
  # Installer Python
  - task: UsePythonVersion@0
    inputs:
      versionSpec: '3.10'
    displayName: 'Installer Python 3.10'
  
  # Installer d√©pendances
  - script: |
      pip install -r requirements.txt
      pip install databricks-cli
    displayName: 'Installer d√©pendances'
  
  # Configuration Databricks CLI
  - script: |
      cat > ~/.databrickscfg <<EOF
      [DEFAULT]
      host = $(DATABRICKS_HOST)
      token = $(DATABRICKS_TOKEN)
      EOF
      
      databricks jobs configure --version=2.1
      echo "‚úÖ CLI Databricks configur√©e"
    displayName: 'Configurer Databricks CLI'
  
  # D√©tecter les notebooks modifi√©s
  - script: |
      echo "üîç D√âTECTION DES NOTEBOOKS MODIFI√âS"
      echo "=================================="
      echo ""
      
      # Obtenir les fichiers modifi√©s
      CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD | grep "^notebooks/.*\.(py|ipynb)$" || true)
      
      if [ -z "$CHANGED_FILES" ]; then
        echo "‚ö†Ô∏è Aucun notebook modifi√© dans ce commit"
        echo "##vso[task.setvariable variable=HAS_CHANGES]false"
        echo "##vso[task.setvariable variable=CHANGED_NOTEBOOKS]"
        exit 0
      fi
      
      echo "üìù Notebooks modifi√©s d√©tect√©s:"
      echo "$CHANGED_FILES"
      echo ""
      
      # Sauvegarder la liste des notebooks modifi√©s
      echo "$CHANGED_FILES" > /tmp/changed_notebooks.txt
      
      # Cr√©er une variable pour les scripts suivants
      echo "##vso[task.setvariable variable=HAS_CHANGES]true"
      
      # Compter le nombre de notebooks
      COUNT=$(echo "$CHANGED_FILES" | wc -l)
      echo "üìä Nombre de notebooks √† d√©ployer: $COUNT"
      
    displayName: 'üîç D√©tecter notebooks modifi√©s'
  
  # D√©ployer UNIQUEMENT les notebooks modifi√©s
  - script: |
      if [ "$(HAS_CHANGES)" = "false" ]; then
        echo "‚è≠Ô∏è Aucun changement, skip du d√©ploiement"
        exit 0
      fi
      
      echo "üì§ D√âPLOIEMENT DES NOTEBOOKS MODIFI√âS"
      echo "====================================="
      echo ""
      
      # Lire la liste des notebooks modifi√©s
      while IFS= read -r notebook_path; do
        if [ -f "$notebook_path" ]; then
          filename=$(basename "$notebook_path")
          echo "üì¶ D√©ploiement de: $filename"
          
          # D√©terminer le format
          if [[ "$notebook_path" == *.ipynb ]]; then
            FORMAT="JUPYTER"
          else
            FORMAT="SOURCE"
          fi
          
          # D√©ployer le notebook
          databricks workspace import "$notebook_path" \
            "$(DATABRICKS_WORKSPACE_PATH)/$filename" \
            --language PYTHON \
            --format $FORMAT \
            --overwrite
          
          if [ $? -eq 0 ]; then
            echo "‚úÖ $filename d√©ploy√© avec succ√®s"
          else
            echo "‚ùå Erreur lors du d√©ploiement de $filename"
            exit 1
          fi
          echo ""
        fi
      done < /tmp/changed_notebooks.txt
      
      echo "‚úÖ TOUS LES NOTEBOOKS MODIFI√âS ONT √âT√â D√âPLOY√âS"
      
    displayName: 'üì§ D√©ployer notebooks modifi√©s'
    condition: eq(variables['HAS_CHANGES'], 'true')
  
  # Ex√©cuter UNIQUEMENT les notebooks modifi√©s
  - script: |
      if [ "$(HAS_CHANGES)" = "false" ]; then
        echo "‚è≠Ô∏è Aucun changement, skip de l'ex√©cution"
        exit 0
      fi
      
      cat > execute_changed_notebooks.py <<'PYTHON_SCRIPT'
      import os
      import sys
      import time
      from pathlib import Path
      from databricks_cli.sdk.api_client import ApiClient
      from databricks_cli.runs.api import RunsApi
      
      # Configuration
      host = os.environ['DATABRICKS_HOST']
      token = os.environ['DATABRICKS_TOKEN']
      workspace_path = os.environ['DATABRICKS_WORKSPACE_PATH']
      
      # Cr√©er le client API
      api_client = ApiClient(host=host, token=token)
      runs_api = RunsApi(api_client)
      
      # Lire la liste des notebooks modifi√©s
      with open('/tmp/changed_notebooks.txt', 'r') as f:
          changed_files = [line.strip() for line in f if line.strip()]
      
      # Extraire uniquement les noms de fichiers
      notebooks = [Path(f).name for f in changed_files]
      
      print("=" * 80)
      print("üöÄ EX√âCUTION DES NOTEBOOKS MODIFI√âS")
      print("=" * 80)
      print(f"\nüìù Notebooks √† ex√©cuter: {notebooks}\n")
      
      def run_notebook(notebook_name):
          """Ex√©cute un notebook et attend la fin"""
          print(f"\n{'='*60}")
          print(f"üöÄ Ex√©cution de: {notebook_name}")
          print('='*60)
          
          try:
              # Param√®tres d'ex√©cution
              run_params = {
                  "notebook_task": {
                      "notebook_path": f"{workspace_path}/{notebook_name}",
                      "base_parameters": {}
                  },
                  "new_cluster": {
                      "spark_version": "13.3.x-scala2.12",
                      "node_type_id": "Standard_DS3_v2",
                      "num_workers": 1
                  }
              }
              
              # Lancer l'ex√©cution
              response = runs_api.submit_run(**run_params)
              run_id = response['run_id']
              
              print(f"‚úÖ Ex√©cution lanc√©e")
              print(f"üìä Run ID: {run_id}")
              print(f"üîó Lien: {host}/#job/0/run/{run_id}")
              print(f"\n‚è≥ Attente de la fin de l'ex√©cution...")
              
              # Attendre la fin
              start_time = time.time()
              while True:
                  run_info = runs_api.get_run(run_id)
                  state = run_info['state']['life_cycle_state']
                  elapsed = int(time.time() - start_time)
                  
                  print(f"‚è±Ô∏è  √âtat: {state} (temps √©coul√©: {elapsed}s)")
                  
                  if state in ['TERMINATED', 'SKIPPED', 'INTERNAL_ERROR']:
                      result_state = run_info['state'].get('result_state', 'UNKNOWN')
                      
                      print(f"\n{'='*60}")
                      if result_state == 'SUCCESS':
                          print(f"‚úÖ {notebook_name} ex√©cut√© avec SUCC√àS")
                          print(f"‚è±Ô∏è  Dur√©e totale: {elapsed}s")
                          print('='*60)
                          return True
                      else:
                          print(f"‚ùå {notebook_name} a √âCHOU√â: {result_state}")
                          if 'state_message' in run_info['state']:
                              print(f"üí¨ Message: {run_info['state']['state_message']}")
                          print('='*60)
                          return False
                  
                  time.sleep(15)
                  
          except Exception as e:
              print(f"\n‚ùå ERREUR lors de l'ex√©cution de {notebook_name}:")
              print(f"   {str(e)}")
              return False
      
      # Ex√©cuter tous les notebooks modifi√©s
      all_success = True
      results = []
      
      for i, notebook in enumerate(notebooks, 1):
          print(f"\n\nüìç Notebook {i}/{len(notebooks)}")
          success = run_notebook(notebook)
          results.append((notebook, success))
          
          if not success:
              all_success = False
              print(f"\n‚ö†Ô∏è  Arr√™t de l'ex√©cution suite √† l'√©chec de {notebook}")
              break
      
      # R√©sum√© final
      print("\n\n" + "=" * 80)
      print("üìä R√âSUM√â DE L'EX√âCUTION")
      print("=" * 80)
      
      for notebook, success in results:
          status = "‚úÖ SUCC√àS" if success else "‚ùå √âCHEC"
          print(f"  {status}  {notebook}")
      
      print("\n" + "=" * 80)
      if all_success:
          print("üéâ TOUS LES NOTEBOOKS ONT √âT√â EX√âCUT√âS AVEC SUCC√àS")
          print("=" * 80)
          sys.exit(0)
      else:
          print("‚ùå CERTAINS NOTEBOOKS ONT √âCHOU√â")
          print("=" * 80)
          sys.exit(1)
      PYTHON_SCRIPT
      
      python execute_changed_notebooks.py
      
    displayName: 'üöÄ Ex√©cuter notebooks modifi√©s'
    env:
      DATABRICKS_HOST: $(DATABRICKS_HOST)
      DATABRICKS_TOKEN: $(DATABRICKS_TOKEN)
      DATABRICKS_WORKSPACE_PATH: $(DATABRICKS_WORKSPACE_PATH)
    condition: eq(variables['HAS_CHANGES'], 'true')